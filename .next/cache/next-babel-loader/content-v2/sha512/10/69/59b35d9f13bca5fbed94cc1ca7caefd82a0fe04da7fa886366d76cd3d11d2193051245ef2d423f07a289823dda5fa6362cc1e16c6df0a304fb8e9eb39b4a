{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport NodeCache from 'node-cache';\nimport { getNetwork } from 'utils/Networks';\nimport { validUrlParams } from 'utils/Sitemap';\nconst myCache = new NodeCache();\nconst defaultMediaType = String(process.env['DEFAULT_MEDIA_TYPE']);\nconst defaultMktType = String(process.env['DEFAULT_MKT_TYPE']);\nconst defaultCategory = String(process.env['DEFAULT_CATEGORY']);\nconst defaultUrl = '';\nconst {\n  endpoint,\n  method,\n  headers,\n  count\n} = getNetwork(defaultMediaType);\nconst requestOption = {\n  method,\n  headers\n};\nconst keepContentsSecond = Number(process.env.KEEP_CONTENTS_SECOND) * 1000;\nconst keepContentsCnt = Number(process.env['KEEP_CONTENTS_CNT']);\n\nclass Monitor {\n  constructor() {\n    _defineProperty(this, \"isLogging\", false);\n  }\n\n}\n\nclass ContentsValues {\n  constructor(merged = [], fetched = [], cached = []) {\n    this.merged = merged;\n    this.fetched = fetched;\n    this.cached = cached;\n  }\n\n}\n\nclass Requests extends Monitor {\n  constructor(query, referers) {\n    super();\n\n    _defineProperty(this, \"mktType\", defaultMktType);\n\n    _defineProperty(this, \"category\", defaultCategory);\n\n    _defineProperty(this, \"url\", defaultUrl);\n\n    _defineProperty(this, \"isSame\", false);\n\n    _defineProperty(this, \"fetched\", false);\n\n    if (query.mktType) this.mktType = query.mktType;\n    if (query.category) this.category = query.category;\n    if (query.url) this.url = query.url;\n    this.isSame = this.mktType !== referers.mktType || this.category !== referers.category;\n  }\n\n  get fetchUrl() {\n    const mktQuery = `mkt=${this.mktType}`;\n    const categoryQery = this.category === defaultCategory ? '' : `&Category=${this.category}`;\n    const countQuery = `&count=${count}`;\n    return endpoint + mktQuery + categoryQery + countQuery;\n  }\n\n  async fetch() {\n    console.log(`EXE FETCH ${this.mktType} ${this.category} ${count}`);\n    const response = await fetch(this.fetchUrl, requestOption);\n    if (response.status !== 200) throw `RESPONSE EROOR: ${response.status} ${this.fetchUrl}`;\n    this.fetched = true;\n    return await response.json();\n  }\n\n}\n\nclass Referers extends Monitor {\n  constructor(referer) {\n    super();\n\n    _defineProperty(this, \"mktType\", '');\n\n    _defineProperty(this, \"category\", '');\n\n    const splitedReferer = referer ? referer.split('/') : [];\n\n    if (splitedReferer.length >= 3 && splitedReferer[2] !== '') {\n      this.mktType = splitedReferer && splitedReferer[2];\n    }\n\n    if (splitedReferer.length >= 4 && splitedReferer[3] !== '') {\n      this.category = splitedReferer && splitedReferer[3].indexOf('?') >= 0 ? splitedReferer[3].split('?')[0] : splitedReferer[4];\n    }\n  }\n\n}\n\nclass MyCache extends Monitor {\n  constructor(requests, nowUnixtime) {\n    super();\n\n    _defineProperty(this, \"key\", '');\n\n    _defineProperty(this, \"nowUnixtime\", void 0);\n\n    this.nowUnixtime = nowUnixtime;\n    this.key = `json/${defaultMediaType}/${requests.mktType}/${requests.category}`;\n  }\n\n  get has() {\n    return myCache.has(this.key);\n  } // キャッシュ更新から、n時間経過している場合はfetchを実行して連結する\n\n\n  get isRequireConcat() {\n    if (this.isLogging) {\n      console.log(new Date(this.nowUnixtime));\n      console.log(new Date(this.generateUnixtime));\n      console.log(new Date(this.generateUnixtime + keepContentsSecond));\n      console.log(this.nowUnixtime > this.generateUnixtime + keepContentsSecond);\n    }\n\n    return this.nowUnixtime > this.generateUnixtime + keepContentsSecond;\n  }\n\n  get generateUnixtime() {\n    if (this.has) {\n      const contentsCache = myCache.get(this.key);\n      return contentsCache.generateUnixtime;\n    } else {\n      return 0;\n    }\n  }\n\n  set(contents) {\n    const contentsCache = {\n      contents,\n      generateUnixtime: this.nowUnixtime\n    };\n    return myCache.set(this.key, contentsCache, 36000);\n  }\n\n  get() {\n    const contentsCache = myCache.get(this.key);\n    return contentsCache.contents;\n  }\n\n}\n\nexport const getServerSidePropsWrap = async ({\n  req,\n  res,\n  query\n}) => {\n  const nowUnixtime = new Date().getTime();\n  let contentsValues = new ContentsValues();\n  const referers = new Referers(String(req.headers.referer));\n  const requests = new Requests(query, referers);\n  const myCache = new MyCache(requests, nowUnixtime); // redirect root if invalid url.\n\n  if (validUrlParams(requests.mktType, requests.category)) {\n    res.writeHead(302, {\n      Location: '/'\n    });\n    res.end();\n  }\n\n  console.log(`@@@ getServerSidePropsWrap @@@ ${myCache.key}`);\n  console.log(myCache.has);\n\n  if (myCache.has) {\n    contentsValues.cached = myCache.get();\n    contentsValues.merged = contentsValues.cached;\n\n    if (myCache.isRequireConcat) {\n      contentsValues = await fetchProcess(requests, contentsValues, myCache);\n    }\n  } else {\n    contentsValues = await fetchProcess(requests, contentsValues, myCache);\n  }\n\n  requests.url = requests.url === '' && contentsValues.merged.length > 0 ? contentsValues.merged[0].url : requests.url;\n  return {\n    props: _objectSpread(_objectSpread({}, requests), {}, {\n      contents: contentsValues.merged\n    })\n  };\n};\n\nconst fetchProcess = async (requests, contentsValues, myCache) => {\n  const responseJson = await requests.fetch();\n  contentsValues.fetched = responseJson.value;\n  contentsValues.merged = saveContentsSwitch(contentsValues, myCache);\n  contentsValues.cached = contentsValues.merged;\n  return contentsValues;\n};\n\nconst saveContentsSwitch = (contentsValue, myCache) => {\n  contentsValue.merged = contentsValue.fetched;\n  let existCachedContents = false;\n  let existFetchedContens = false;\n  if (contentsValue.cached.length > 0) existCachedContents = true;\n  if (contentsValue.fetched.length > 0) existFetchedContens = true; // fetch成功してcacheが存在してた場合 -> 連結&ソートして返す\n\n  if (existFetchedContens && existCachedContents) {\n    const cachedLastUnixtime = new Date(contentsValue.cached[0].datePublished).getTime();\n    contentsValue.merged = contentsValue.cached;\n    contentsValue.fetched.sort(sortContents);\n    const addFetchContentsIndex = contentsValue.fetched.findIndex(value => {\n      const fetchedUnixtime = new Date(value.datePublished).getTime();\n      return fetchedUnixtime < cachedLastUnixtime;\n    });\n    const addFetchContents = contentsValue.fetched.slice(0, addFetchContentsIndex - 1);\n    contentsValue.merged = addFetchContents.concat(contentsValue.merged);\n    contentsValue.merged = contentsValue.merged.slice(0, keepContentsCnt);\n    console.log(`> UPDATE( CONCAT & SORT ) CACHE fetchLast: ${myCache.generateUnixtime}`);\n    myCache.set(contentsValue.merged);\n  } else if (existFetchedContens && !existCachedContents) {\n    console.log('> CREATE NEW CACHE');\n    contentsValue.fetched.sort(sortContents);\n    contentsValue.merged = contentsValue.fetched;\n    contentsValue.merged = contentsValue.merged.slice(0, keepContentsCnt);\n    myCache.set(contentsValue.merged);\n  } else if (!existFetchedContens && existCachedContents) {\n    console.log('> NO FETCH & BACK CACHE');\n    contentsValue.merged = contentsValue.cached;\n  } else {\n    console.log('> NO FETCH & NO CACHE');\n    contentsValue.merged = contentsValue.fetched;\n    myCache.set(contentsValue.merged);\n  }\n\n  return contentsValue.merged;\n};\n\nconst sortContents = (a, b) => {\n  if (a.datePublished < b.datePublished) return 1;\n  if (a.datePublished > b.datePublished) return -1;\n  return 0;\n};","map":null,"metadata":{},"sourceType":"module"}