{"version":3,"file":"main.js","sources":["../../output/main-thread/serialize.js","../../output/main-thread/debugging.js"],"sourcesContent":["/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { applyDefaultInputListener, sendValueChangeOnAttributeMutation } from './commands/event-subscription';\nconst NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT = [8 /* COMMENT_NODE */, 3 /* TEXT_NODE */];\n/**\n * Serializes a DOM element for transport to the worker.\n * @param element\n * @param minimizeString Function for minimizing strings for optimized ferrying across postMessage.\n */\nfunction createHydrateableNode(element, minimizeString, hydrateFilter, workerContext) {\n    const filteredChildNodes = [].slice.call(element.childNodes).filter(hydrateFilter);\n    const hydrated = {\n        [7 /* index */]: element._index_,\n        [11 /* transferred */]: 0 /* FALSE */,\n        [0 /* nodeType */]: element.nodeType,\n        [1 /* localOrNodeName */]: minimizeString(element.localName || element.nodeName),\n        [4 /* childNodes */]: filteredChildNodes.map((child) => createHydrateableNode(child, minimizeString, hydrateFilter, workerContext)),\n        [2 /* attributes */]: [].map.call(element.attributes || [], (attribute) => [\n            minimizeString(attribute.namespaceURI || 'null'),\n            minimizeString(attribute.name),\n            minimizeString(attribute.value),\n        ]),\n    };\n    if (element.namespaceURI != null) {\n        hydrated[6 /* namespaceURI */] = minimizeString(element.namespaceURI);\n    }\n    if (NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT.includes(element.nodeType) && element.textContent !== null) {\n        hydrated[5 /* textContent */] = minimizeString(element.textContent);\n    }\n    applyDefaultInputListener(workerContext, element);\n    sendValueChangeOnAttributeMutation(workerContext, element);\n    return hydrated;\n}\n/**\n * @param element\n */\nexport function createHydrateableRootNode(element, config, workerContext) {\n    const hydrateFilter = config.hydrateFilter || (() => true);\n    const strings = [];\n    const stringMap = new Map();\n    const storeString = (value) => {\n        if (stringMap.has(value)) {\n            // Safe to cast since we verified the mapping contains the value.\n            return stringMap.get(value);\n        }\n        const count = strings.length;\n        stringMap.set(value, count);\n        strings.push(value);\n        return count;\n    };\n    const skeleton = createHydrateableNode(element, storeString, hydrateFilter, workerContext);\n    return { skeleton, strings };\n}\n/**\n * @param element\n */\nexport function createReadableHydrateableRootNode(element, config, workerContext) {\n    // \"Readable\" variant doesn't do any string minimization so we can output it for debugging purposes.\n    // Note that this intentionally breaks the type contract of createHydrateableNode() and HydrateableNode.\n    return createHydrateableNode(element, ((value) => value), config.hydrateFilter || (() => true), workerContext);\n}\n//# sourceMappingURL=serialize.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createReadableHydrateableRootNode } from './serialize';\n/**\n * @param element\n */\nexport const readableHydrateableRootNode = (element, config, workerContext) => readableHydrateableNode(createReadableHydrateableRootNode(element, config, workerContext));\n/**\n * @param nodeContext {NodeContext}\n * @param node {TransferredNode}\n */\nexport const readableTransferredNode = (nodeContext, node) => (node != null && nodeContext.getNode(node[0 /* Index */])) || node;\n/**\n * @param node\n */\nfunction readableHydrateableNode(node) {\n    const out = {\n        nodeType: node[0 /* nodeType */],\n        name: node[1 /* localOrNodeName */],\n        attributes: null,\n        childNodes: null,\n    };\n    const attributes = node[2 /* attributes */];\n    if (attributes) {\n        out.attributes = attributes.map((attr) => ({\n            name: attr[1],\n            value: attr[2],\n        }));\n    }\n    const childNodes = node[4 /* childNodes */];\n    if (childNodes) {\n        out.childNodes = childNodes.map(readableHydrateableNode);\n    }\n    return out;\n}\n/**\n * @param message {MessageToWorker}\n */\nconst isEvent = (message) => message[12 /* type */] == 1 /* EVENT */;\nconst isValueSync = (message) => message[12 /* type */] == 4 /* SYNC */;\nconst isBoundingClientRect = (message) => message[12 /* type */] === 6 /* GET_BOUNDING_CLIENT_RECT */;\n/**\n * @param nodeContext {NodeContext}\n * @param event {TransferrableEvent}\n */\nfunction readableTransferrableEvent(nodeContext, event) {\n    const value = (item) => {\n        if (typeof item === 'number' || typeof item === 'boolean') {\n            return item !== undefined ? item : null;\n        }\n        return item !== undefined && item !== null ? readableTransferredNode(nodeContext, item) : null;\n    };\n    return {\n        type: event[12 /* type */],\n        bubbles: value(event[25 /* bubbles */]),\n        cancelable: value(event[26 /* cancelable */]),\n        cancelBubble: value(event[27 /* cancelBubble */]),\n        defaultPrevented: value(event[29 /* defaultPrevented */]),\n        eventPhase: value(event[30 /* eventPhase */]),\n        isTrusted: value(event[31 /* isTrusted */]),\n        returnValue: value(event[32 /* returnValue */]),\n        currentTarget: value(event[28 /* currentTarget */]),\n        target: value(event[13 /* target */]),\n        scoped: value(event[34 /* scoped */]),\n        keyCode: value(event[35 /* keyCode */]),\n    };\n}\n/**\n * @param nodeContext {NodeContext}\n * @param value {TransferrableSyncValue}\n */\nfunction readableTransferrableSyncValue(nodeContext, value) {\n    const index = value[7 /* index */];\n    return {\n        target: nodeContext.getNode(index) || index,\n        value: value[21 /* value */],\n    };\n}\n/**\n * @param message\n */\nexport function readableMessageToWorker(nodeContext, message) {\n    if (isEvent(message)) {\n        const event = message[39 /* event */];\n        return {\n            type: 'EVENT',\n            event: readableTransferrableEvent(nodeContext, event),\n        };\n    }\n    else if (isValueSync(message)) {\n        const sync = message[40 /* sync */];\n        return {\n            type: 'SYNC',\n            sync: readableTransferrableSyncValue(nodeContext, sync),\n        };\n    }\n    else if (isBoundingClientRect(message)) {\n        return {\n            type: 'GET_BOUNDING_CLIENT_RECT',\n            target: readableTransferredNode(nodeContext, message[13 /* target */]),\n        };\n    }\n    else {\n        return 'Unrecognized MessageToWorker type: ' + message[12 /* type */];\n    }\n}\n//# sourceMappingURL=debugging.js.map"],"names":["createHydrateableNode","readableHydrateableNode","readableTransferrableEvent"],"mappings":"+/DA8BAA,8bCmBAC,qMAoCAC"}